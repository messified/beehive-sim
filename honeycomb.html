<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Beehive Construction Simulator</title>
  <style>
    :root { color-scheme: dark; }

    html, body {
      height: 100%;
      margin: 0;
      background:#0b0f14;
      color:#e7eef7;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overscroll-behavior: none;
    }

    .wrap { display:flex; flex-direction:column; height:100%; min-height:0; }

    header {
      padding: 10px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.00));
      flex: 0 0 auto;
    }
    header h1 { margin:0; font-size: 12px; letter-spacing: .6px; text-transform: uppercase; opacity:.95; }
    header .sub { font-size: 12px; opacity:.75; white-space: nowrap; }

    main { display:flex; flex:1; min-height:0; }

    /* Panel (desktop default) */
    .panel {
      width: 340px;
      max-width: 44vw;
      min-width: 280px;
      padding: 12px;
      border-right: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.02);
      overflow:auto;
      box-sizing: border-box;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }

    .panelHeader {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      position: sticky;
      top: 0;
      padding: 4px 0 8px;
      background: linear-gradient(180deg, rgba(11,15,20,0.95), rgba(11,15,20,0.70));
      backdrop-filter: blur(6px);
      z-index: 2;
    }

    .sectionTitle {
      margin: 0;
      font-size: 12px;
      letter-spacing:.5px;
      text-transform: uppercase;
      opacity:.9;
    }

    .control {
      display:grid;
      grid-template-columns: 1fr auto;
      grid-template-rows: auto auto;
      column-gap: 10px;
      row-gap: 8px;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.18);
    }
    .control label { grid-column: 1; grid-row: 1; font-size: 12px; opacity:.9; }
    .control .value { grid-column: 2; grid-row: 1; font-size: 12px; opacity:.8; font-variant-numeric: tabular-nums; }
    .control input[type="range"] { grid-column: 1 / span 2; grid-row: 2; width: 100%; margin: 0; }

    .btns {
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .btns button:nth-child(1) { grid-column: 1 / span 2; }

    button {
      appearance:none;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color:#e7eef7;
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-size:12px;
      letter-spacing:.2px;
      touch-action: manipulation;
    }
    button:hover { background: rgba(255,255,255,0.10); }
    button:active { transform: translateY(1px); }

    .btnGhost {
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.10);
      font-size: 12px;
      white-space: nowrap;
    }

    .card {
      padding: 10px;
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      background: rgba(0,0,0,0.18);
      font-size: 12px;
      line-height: 1.4;
    }

    .legendRow { display:flex; align-items:center; gap:10px; margin: 6px 0; }
    .dot { width:10px; height:10px; border-radius: 3px; flex: 0 0 auto; }
    .hint { font-size: 12px; opacity:.72; }

    .canvasWrap { position:relative; flex:1; min-width:0; }
    canvas { width:100%; height:100%; display:block; touch-action: none; }

    .badge {
      position:absolute; left:12px; bottom:12px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
      font-size: 12px; line-height:1.35;
      max-width: min(560px, calc(100% - 24px));
      box-sizing: border-box;
      pointer-events: none;
    }
    .badge .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; opacity:.9; }

    /* --- Mobile optimization: bottom sheet controls --- */
    @media (max-width: 860px) {
      header .sub { display:none; } /* keep header tight */
      main { flex-direction:column; }

      .panel {
        width: 100%;
        max-width: none;
        min-width: 0;
        border-right: none;
        border-top: 1px solid rgba(255,255,255,0.08);
        position: fixed;
        left: 0; right: 0;
        bottom: 0;
        z-index: 10;
        padding: 10px 12px calc(12px + env(safe-area-inset-bottom));
        background: rgba(11,15,20,0.85);
        backdrop-filter: blur(10px);
        max-height: 62vh;
        transform: translateY(0);
        transition: transform 220ms ease;
        border-radius: 16px 16px 0 0;
      }

      .panel.collapsed {
        transform: translateY(calc(100% - 64px));
      }

      .panelHeader {
        position: sticky;
        top: 0;
        background: transparent;
        padding: 0 0 8px;
        backdrop-filter: none;
      }

      .grab {
        width: 42px;
        height: 4px;
        border-radius: 999px;
        background: rgba(255,255,255,0.18);
        margin: 2px auto 8px;
      }

      .btns { grid-template-columns: 1fr 1fr 1fr; }
      .btns button:nth-child(1) { grid-column: 1 / span 3; }

      .badge { bottom: calc(12px + 72px); } /* float above collapsed panel header */
    }

    /* Reduced motion (accessibility) */
    @media (prefers-reduced-motion: reduce) {
      .panel { transition: none !important; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Beehive Construction Simulator</h1>
      </div>
      <button id="panelToggleTop" class="btnGhost" aria-controls="panel" aria-expanded="true">Controls</button>
    </header>

    <main>
      <section class="canvasWrap">
        <canvas id="c"></canvas>
        <div class="badge">
          <div><b>Model:</b> Visual simulation (stylized).</div>
          <div class="mono">Gold comb persists • flowing trails • particle sparks</div>
          <div class="mono" style="opacity:.75">Pan: drag • Zoom: pinch / wheel</div>
        </div>
      </section>

      <aside class="panel" id="panel" aria-label="Control panel">
        <div class="grab" aria-hidden="true"></div>
        <div class="panelHeader">
          <h2 class="sectionTitle">Controls</h2>
          <button id="panelToggle" class="btnGhost" aria-controls="panel" aria-expanded="true">Hide</button>
        </div>

        <div class="control">
          <label for="colony">Colony size</label>
          <div class="value" id="colonyVal"></div>
          <input id="colony" type="range" min="50" max="2000" step="10" value="650" />
        </div>

        <div class="control">
          <label for="resources">Resource availability</label>
          <div class="value" id="resourcesVal"></div>
          <input id="resources" type="range" min="0" max="100" step="1" value="62" />
        </div>

        <div class="control">
          <label for="speed">Simulation speed</label>
          <div class="value" id="speedVal"></div>
          <input id="speed" type="range" min="0.25" max="2.5" step="0.05" value="1.00" />
        </div>

        <div class="btns">
          <button id="toggle">Pause</button>
          <button id="reset">Reset</button>
          <button id="center">Recenter</button>
        </div>

        <div class="card">
          <div class="legendRow"><span class="dot" style="background:#2a3544;"></span><div>Unbuilt</div></div>
          <div class="legendRow"><span class="dot" style="background:#f0c24b;"></span><div>Built comb (stays gold)</div></div>
          <div class="legendRow"><span class="dot" style="background:#ffd35a;"></span><div>Honey storage (glow + cap)</div></div>
          <div class="legendRow"><span class="dot" style="background:#7dd3fc;"></span><div>Worker paths (spark + flow)</div></div>
        </div>

        <div class="card" id="stats"></div>
        <div class="hint">Tip: More resources pushes bees outward and increases honey storage density.</div>
      </aside>
    </main>
  </div>

<script>
(() => {
  // -----------------------------
  // Helpers
  // -----------------------------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t) => a + (b-a)*t;
  const rand = (a=1,b=0) => Math.random()*(a-b)+b;
  const pick = (arr) => arr[(Math.random()*arr.length)|0];
  const keyAx = (q,r) => `${q},${r}`;
  const TAU = Math.PI * 2;
  const easeInOut = (t) => t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;

  function hexDist(q1,r1,q2,r2) {
    const dq = q1 - q2;
    const dr = r1 - r2;
    const ds = (q1+r1) - (q2+r2);
    return (Math.abs(dq)+Math.abs(dr)+Math.abs(ds))/2;
  }

  // -----------------------------
  // Panel show/hide (mobile bottom sheet + desktop sidebar)
  // -----------------------------
  const panel = document.getElementById('panel');
  const panelToggle = document.getElementById('panelToggle');
  const panelToggleTop = document.getElementById('panelToggleTop');

  function isMobileLayout() {
    return window.matchMedia && window.matchMedia('(max-width: 860px)').matches;
  }

  function setPanelCollapsed(collapsed) {
    panel.classList.toggle('collapsed', collapsed);
    const expanded = !collapsed;
    panelToggle.textContent = expanded ? 'Hide' : 'Show';
    panelToggle.setAttribute('aria-expanded', String(expanded));
    panelToggleTop.setAttribute('aria-expanded', String(expanded));
    panelToggleTop.textContent = expanded ? 'Controls' : 'Show Controls';
  }

  // Default: on mobile start collapsed, desktop expanded
  function initPanelState() {
    setPanelCollapsed(isMobileLayout());
  }

  panelToggle.addEventListener('click', () => setPanelCollapsed(!panel.classList.contains('collapsed')));
  panelToggleTop.addEventListener('click', () => setPanelCollapsed(!panel.classList.contains('collapsed')));

  window.addEventListener('resize', () => {
    // If crossing layout threshold, pick a sensible default
    // (don’t be too clever: just keep current state, but if panel got "stuck" hidden on desktop, show it)
    if (!isMobileLayout()) setPanelCollapsed(false);
  });

  // Mobile: swipe up/down on the panel to show/hide
  let sheetDrag = { active:false, startY:0, startCollapsed:false, moved:false };
  panel.addEventListener('pointerdown', (e) => {
    if (!isMobileLayout()) return;
    // Only allow swipe when started near the top (header/grab zone)
    const rect = panel.getBoundingClientRect();
    const yInPanel = e.clientY - rect.top;
    if (yInPanel > 90) return;
    sheetDrag.active = true;
    sheetDrag.startY = e.clientY;
    sheetDrag.startCollapsed = panel.classList.contains('collapsed');
    sheetDrag.moved = false;
    panel.setPointerCapture(e.pointerId);
  });
  panel.addEventListener('pointermove', (e) => {
    if (!sheetDrag.active) return;
    const dy = e.clientY - sheetDrag.startY;
    if (Math.abs(dy) > 8) sheetDrag.moved = true;
  });
  panel.addEventListener('pointerup', (e) => {
    if (!sheetDrag.active) return;
    sheetDrag.active = false;
    if (!sheetDrag.moved) return;
    const dy = e.clientY - sheetDrag.startY;
    // swipe down => collapse, swipe up => expand
    if (dy > 20) setPanelCollapsed(true);
    if (dy < -20) setPanelCollapsed(false);
  });

  // -----------------------------
  // Canvas + DPI
  // -----------------------------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  function resizeCanvas() {
    const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resizeCanvas);

  // -----------------------------
  // Controls
  // -----------------------------
  const colonyEl = document.getElementById('colony');
  const resourcesEl = document.getElementById('resources');
  const speedEl = document.getElementById('speed');

  const colonyVal = document.getElementById('colonyVal');
  const resourcesVal = document.getElementById('resourcesVal');
  const speedVal = document.getElementById('speedVal');

  const statsEl = document.getElementById('stats');
  const toggleBtn = document.getElementById('toggle');
  const resetBtn = document.getElementById('reset');
  const centerBtn = document.getElementById('center');

  // -----------------------------
  // Hex grid math
  // -----------------------------
  const axialDirs = [
    [ 1, 0], [ 1,-1], [ 0,-1],
    [-1, 0], [-1, 1], [ 0, 1]
  ];

  function axialToPixel(q, r, size, ox, oy) {
    const x = size * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r);
    const y = size * (3/2 * r);
    return { x: x + ox, y: y + oy };
  }

  function hexCorner(cx, cy, size, i) {
    const angle = (Math.PI / 180) * (60 * i - 30);
    return { x: cx + size * Math.cos(angle), y: cy + size * Math.sin(angle) };
  }

  function hexPath(x, y, size) {
    ctx.beginPath();
    const c0 = hexCorner(x, y, size, 0);
    ctx.moveTo(c0.x, c0.y);
    for (let i=1;i<6;i++) {
      const c = hexCorner(x, y, size, i);
      ctx.lineTo(c.x, c.y);
    }
    ctx.closePath();
  }

  // -----------------------------
  // Simulation state
  // -----------------------------
  let running = true;
  let view = { panX: 0, panY: 0, zoom: 1 };

  let cells = new Map();
  let builtSet = new Set();
  let frontier = new Set();
  let honeyKeys = new Set();

  let trails = [];     // {x1,y1,x2,y2,life,phase,width}
  let sparks = [];     // {x,y,vx,vy,life}
  let workers = [];    // {q,r,tq,tr,t,jitterSeed,heading}

  let builtTime = new Map(); // key -> time
  let simTime = 0;
  let tBuildAccum = 0;
  let tick = 0;

  function currentParams() {
    const colony = +colonyEl.value;
    const resources = +resourcesEl.value;
    const speed = +speedEl.value;

    const radius = clamp(Math.round(Math.sqrt(colony) / 4 + 4), 5, 16);
    const workerCount = clamp(Math.round(colony / 55), 6, 95);

    const buildRate = (0.9 + colony / 740) * (0.35 + resources / 120);
    const honeyRate = Math.pow(resources / 100, 1.10);
    const storageBias = clamp(0.14 + (resources / 100) * 0.48, 0.14, 0.62);

    const moveSpeed = clamp(1.2 + (colony / 1100) + (resources / 150), 1.2, 3.6);

    const trailKeep = clamp(900 + workerCount * 16, 900, 2600);
    const sparkRate = clamp(0.02 + workerCount / 2200, 0.02, 0.10);

    return { colony, resources, speed, radius, workerCount, buildRate, honeyRate, storageBias, moveSpeed, trailKeep, sparkRate };
  }

  function setLabels() {
    const { colony, resources, speed } = currentParams();
    colonyVal.textContent = `${colony.toLocaleString()} bees`;
    resourcesVal.textContent = `${resources}%`;
    speedVal.textContent = `${speed.toFixed(2)}×`;
  }

  function generateGrid(radius) {
    cells.clear();
    builtSet.clear();
    frontier.clear();
    honeyKeys.clear();
    builtTime.clear();

    for (let q = -radius; q <= radius; q++) {
      const r1 = Math.max(-radius, -q - radius);
      const r2 = Math.min(radius, -q + radius);
      for (let r = r1; r <= r2; r++) {
        cells.set(keyAx(q,r), { q, r, built: false, honey: 0 });
      }
    }
  }

  function neighborsOf(q, r) {
    const out = [];
    for (const [dq,dr] of axialDirs) out.push([q+dq, r+dr]);
    return out;
  }

  function rebuildFrontier() {
    frontier.clear();
    for (const k of builtSet) {
      const cell = cells.get(k);
      for (const [nq,nr] of neighborsOf(cell.q, cell.r)) {
        const nk = keyAx(nq,nr);
        const nc = cells.get(nk);
        if (nc && !nc.built) frontier.add(nk);
      }
    }
  }

  function seedStart() {
    const centerK = keyAx(0,0);
    const c0 = cells.get(centerK);
    c0.built = true;
    builtSet.add(centerK);
    builtTime.set(centerK, simTime);

    for (const [dq,dr] of axialDirs) {
      const k = keyAx(dq,dr);
      const c = cells.get(k);
      if (c) { c.built = true; builtSet.add(k); builtTime.set(k, simTime); }
    }
    rebuildFrontier();
  }

  function resetSimulation() {
    simTime = 0;
    const { radius, workerCount } = currentParams();
    generateGrid(radius);
    seedStart();

    trails = [];
    sparks = [];
    workers = [];
    tBuildAccum = 0;
    tick = 0;

    for (let i=0;i<workerCount;i++) {
      workers.push({
        q: 0, r: 0,
        tq: 0, tr: 0,
        t: 1,
        jitterSeed: Math.random()*1000,
        heading: rand(TAU, 0)
      });
    }

    view.panX = 0;
    view.panY = 0;
    view.zoom = 1;
  }

  function syncWorkersToParams() {
    const { workerCount } = currentParams();
    if (workers.length === workerCount) return;
    if (workers.length < workerCount) {
      const add = workerCount - workers.length;
      for (let i=0;i<add;i++) workers.push({ q:0,r:0,tq:0,tr:0,t:1,jitterSeed:Math.random()*1000,heading:rand(TAU,0) });
    } else {
      workers.length = workerCount;
    }
  }

  function chooseFrontierCell(storageBias) {
    if (frontier.size === 0) return null;
    const fArr = Array.from(frontier);
    const sampleN = Math.min(60, fArr.length);

    let best = null;
    let bestScore = -Infinity;

    for (let i=0;i<sampleN;i++) {
      const k = fArr[(Math.random()*fArr.length)|0];
      const c = cells.get(k);
      const dist = hexDist(c.q,c.r, 0,0);

      let score = -dist * 0.52 + rand(0.65, 0);

      if (honeyKeys.size > 0) {
        const hk = pick(Array.from(honeyKeys));
        const hc = cells.get(hk);
        score += -hexDist(c.q,c.r, hc.q,hc.r) * 0.10;
      }

      score += (Math.random() < storageBias ? 0.14 : 0);

      if (score > bestScore) { bestScore = score; best = k; }
    }
    return best;
  }

  function buildStep(storageBias) {
    const k = chooseFrontierCell(storageBias);
    if (!k) return;

    const c = cells.get(k);
    c.built = true;
    builtSet.add(k);
    frontier.delete(k);
    builtTime.set(k, simTime);

    for (const [nq,nr] of neighborsOf(c.q, c.r)) {
      const nk = keyAx(nq,nr);
      const nc = cells.get(nk);
      if (nc && !nc.built) frontier.add(nk);
    }
  }

  function builtNeighbors(q, r) {
    const opts = [];
    for (const [dq,dr] of axialDirs) {
      const nk = keyAx(q+dq, r+dr);
      const nc = cells.get(nk);
      if (nc && nc.built) opts.push(nc);
    }
    return opts;
  }

  function pickWorkerNext(w, honeyRate) {
    const opts = builtNeighbors(w.q, w.r);
    if (!opts.length) return null;

    let best = pick(opts);
    let bestScore = -Infinity;

    for (const c of opts) {
      const distOut = hexDist(c.q,c.r, 0,0);
      const fromDist = hexDist(w.q,w.r, 0,0);

      const angTo = Math.atan2(c.r - w.r, c.q - w.q);
      const dAng = Math.atan2(Math.sin(angTo - w.heading), Math.cos(angTo - w.heading));
      const align = 1 - Math.abs(dAng) / Math.PI;

      let score = align * 0.55 + rand(0.40, 0);

      if (Math.random() < honeyRate * 0.6) score += (distOut - fromDist) * 0.22;
      if (honeyKeys.size && Math.random() < 0.35) {
        const hk = pick(Array.from(honeyKeys));
        const hc = cells.get(hk);
        score += -hexDist(c.q,c.r, hc.q,hc.r) * 0.06;
      }

      if (score > bestScore) { bestScore = score; best = c; }
    }

    w.heading = Math.atan2(best.r - w.r, best.q - w.q);
    return best;
  }

  function depositHoney(honeyRate, storageBias) {
    if (builtSet.size < 8) return;

    const builtArr = Array.from(builtSet);
    const sampleN = Math.min(80, builtArr.length);

    let best = null;
    let bestScore = -Infinity;
    const targetRing = 0.72 * currentParams().radius;

    for (let i=0;i<sampleN;i++) {
      const k = builtArr[(Math.random()*builtArr.length)|0];
      const c = cells.get(k);

      const dist = hexDist(c.q,c.r, 0,0);
      let score = -Math.abs(dist - targetRing) * 0.75;

      const bn = builtNeighbors(c.q,c.r).length;
      score += bn * 0.12;

      score += (1 - c.honey) * 0.95;
      score += (Math.random() < storageBias ? 0.20 : -0.05);
      score += honeyRate * 0.40;
      score += rand(0.30, 0);

      if (score > bestScore) { bestScore = score; best = c; }
    }
    if (!best) return;

    const add = 0.02 + 0.13 * honeyRate * rand(1, 0.35);
    best.honey = clamp(best.honey + add, 0, 1);
    if (best.honey > 0.001) honeyKeys.add(keyAx(best.q,best.r));
  }

  // -----------------------------
  // Rendering
  // -----------------------------
  function getRenderMetrics() {
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;
    const { radius } = currentParams();

    // Slightly larger on mobile so it reads better
    const mobileBoost = isMobileLayout() ? 1.10 : 1.00;

    const baseSize = clamp(Math.min(W,H) / (radius * 5.0), 10, 28) * mobileBoost;
    const size = baseSize * view.zoom;

    const ox = W/2 + view.panX;
    const oy = H/2 + view.panY;

    return { W, H, size, ox, oy };
  }

  function background(W,H) {
    ctx.fillStyle = '#0b0f14';
    ctx.fillRect(0,0,W,H);
  }

  function drawFlowSegment(tr, tPhase) {
    const dx = tr.x2 - tr.x1;
    const dy = tr.y2 - tr.y1;
    const len = Math.hypot(dx, dy) || 1;

    // Base trail
    ctx.globalAlpha = tr.life * 0.55;
    ctx.strokeStyle = 'rgba(125,211,252,1)';
    ctx.lineWidth = tr.width;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(tr.x1, tr.y1);
    ctx.lineTo(tr.x2, tr.y2);
    ctx.stroke();

    // Moving highlight/pulse
    const u = (Math.sin(tPhase + tr.phase) * 0.5 + 0.5);
    const px = tr.x1 + dx * u;
    const py = tr.y1 + dy * u;

    const streak = Math.min(18, len * 0.45);
    const ux = dx / len, uy = dy / len;

    ctx.globalAlpha = tr.life * 0.85;
    ctx.strokeStyle = 'rgba(200,245,255,1)';
    ctx.lineWidth = tr.width * 0.75;
    ctx.beginPath();
    ctx.moveTo(px - ux * streak * 0.6, py - uy * streak * 0.6);
    ctx.lineTo(px + ux * streak * 0.6, py + uy * streak * 0.6);
    ctx.stroke();

    ctx.globalAlpha = 1;
  }

  function spawnSparksAt(x, y, count) {
    for (let i=0;i<count;i++) {
      const a = rand(TAU, 0);
      const sp = rand(35, 12);
      sparks.push({
        x, y,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp,
        life: rand(0.45, 0.18)
      });
    }
  }

  function draw() {
    const { W, H, size, ox, oy } = getRenderMetrics();
    background(W,H);

    const grad = ctx.createRadialGradient(ox, oy, 0, ox, oy, Math.max(W,H)*0.65);
    grad.addColorStop(0, 'rgba(255,255,255,0.035)');
    grad.addColorStop(1, 'rgba(0,0,0,0.50)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,W,H);

    const cellsArr = Array.from(cells.values());
    cellsArr.sort((a,b) => hexDist(a.q,a.r,0,0) - hexDist(b.q,b.r,0,0));

    for (const c of cellsArr) {
      const p = axialToPixel(c.q, c.r, size, ox, oy);
      if (p.x < -90 || p.x > W+90 || p.y < -90 || p.y > H+90) continue;

      const isBuilt = c.built;
      const isHoney = isBuilt && c.honey > 0.001;

      hexPath(p.x, p.y, size * 0.965);
      ctx.lineWidth = 1;

      if (!isBuilt) {
        ctx.strokeStyle = 'rgba(143,168,199,0.06)';
        ctx.stroke();
        continue;
      }

      // Persistent vibrant gold comb
      const bt = builtTime.get(keyAx(c.q,c.r)) ?? 0;
      const age = Math.max(0, simTime - bt);
      const flash = clamp(1 - age / 0.9, 0, 1);
      const combAlpha = 0.24 + 0.18 * flash;

      ctx.fillStyle = `rgba(240,194,75,${combAlpha})`;
      ctx.fill();

      // Inner glow (pop)
      ctx.globalAlpha = 0.38 + flash * 0.25;
      ctx.fillStyle = 'rgba(255,215,120,1)';
      hexPath(p.x, p.y, size * 0.78);
      ctx.fill();
      ctx.globalAlpha = 1;

      if (isHoney) {
        const alpha = lerp(0.30, 0.98, c.honey);
        ctx.fillStyle = `rgba(255,211,90,${alpha})`;
        hexPath(p.x, p.y, size * 0.90);
        ctx.fill();

        if (c.honey > 0.92) {
          ctx.fillStyle = 'rgba(255,255,255,0.12)';
          hexPath(p.x, p.y, size * 0.72);
          ctx.fill();
        }
      }

      ctx.strokeStyle = isHoney
        ? 'rgba(255,230,150,0.42)'
        : 'rgba(255,205,110,0.28)';
      ctx.stroke();

      ctx.globalAlpha = 0.12;
      ctx.strokeStyle = 'rgba(0,0,0,1)';
      ctx.lineWidth = 1.2;
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Trails
    const phaseT = simTime * 6.0;
    for (let i=trails.length-1; i>=0; i--) {
      const tr = trails[i];
      tr.life -= 0.022 * currentParams().speed;
      if (tr.life <= 0) { trails.splice(i,1); continue; }
      drawFlowSegment(tr, phaseT);
    }

    // Sparks
    for (let i=sparks.length-1; i>=0; i--) {
      const sp = sparks[i];
      sp.life -= 0.016 * currentParams().speed;
      if (sp.life <= 0) { sparks.splice(i,1); continue; }
      const a = clamp(sp.life / 0.45, 0, 1);
      ctx.globalAlpha = a * 0.9;
      ctx.fillStyle = 'rgba(210,250,255,1)';
      ctx.beginPath();
      ctx.arc(sp.x, sp.y, 1.3 + (1-a)*0.6, 0, TAU);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Bees
    const beeR = clamp(size * 0.15, 2.4, 6.2);
    for (const w of workers) {
      const t = easeInOut(clamp(w.t, 0, 1));
      const from = axialToPixel(w.q, w.r, size, ox, oy);
      const to = axialToPixel(w.tq, w.tr, size, ox, oy);

      const j = 0.9 + Math.sin((w.jitterSeed + tick*0.12) * 2.1) * 0.6;
      const jx = Math.cos((w.jitterSeed + tick*0.07) * 3.3) * j;
      const jy = Math.sin((w.jitterSeed + tick*0.09) * 2.9) * j;

      const x = lerp(from.x, to.x, t) + jx;
      const y = lerp(from.y, to.y, t) + jy;

      const dx = (to.x - from.x);
      const dy = (to.y - from.y);
      const ang = Math.atan2(dy, dx);

      ctx.globalAlpha = 0.55;
      ctx.fillStyle = 'rgba(255,210,110,1)';
      ctx.beginPath();
      ctx.arc(x, y, beeR*2.0, 0, TAU);
      ctx.fill();

      const wing = 0.55 + 0.45*Math.sin(simTime*18 + w.jitterSeed);
      ctx.globalAlpha = 0.25 + wing*0.18;
      ctx.fillStyle = 'rgba(200,245,255,1)';
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(ang);
      ctx.beginPath();
      ctx.ellipse(-beeR*0.2, -beeR*0.9, beeR*0.75, beeR*0.45, 0.2, 0, TAU);
      ctx.ellipse(-beeR*0.2,  beeR*0.9, beeR*0.75, beeR*0.45,-0.2, 0, TAU);
      ctx.fill();
      ctx.restore();

      ctx.globalAlpha = 0.95;
      ctx.fillStyle = 'rgba(255,210,110,1)';
      ctx.beginPath();
      ctx.arc(x, y, beeR, 0, TAU);
      ctx.fill();

      ctx.globalAlpha = 0.55;
      ctx.strokeStyle = 'rgba(0,0,0,0.85)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x - beeR*0.65, y);
      ctx.lineTo(x + beeR*0.65, y);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Center marker
    const center = axialToPixel(0,0,size,ox,oy);
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.beginPath();
    ctx.arc(center.x, center.y, clamp(size*0.22, 2.6, 7.2), 0, TAU);
    ctx.fill();

    // HUD
    ctx.fillStyle = 'rgba(255,255,255,0.10)';
    ctx.fillRect(12, 12, 224, 66);
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillRect(14, 14, 220, 62);

    const builtCount = builtSet.size;
    const honeyCount = honeyKeys.size;
    const honeyAvg = honeyCount ? (Array.from(honeyKeys).reduce((s,k)=>s+cells.get(k).honey,0)/honeyCount) : 0;
    const { resources } = currentParams();

    ctx.fillStyle = 'rgba(231,238,247,0.92)';
    ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
    ctx.fillText(`built: ${builtCount}`, 22, 36);
    ctx.fillText(`storage: ${honeyCount}`, 22, 54);
    ctx.fillText(`resources: ${String(resources).padStart(3,' ')}%`, 22, 72);
    ctx.fillText(`honey avg: ${(honeyAvg*100).toFixed(0).padStart(3,' ')}%`, 22, 90);
  }

  // -----------------------------
  // Update
  // -----------------------------
  function update(dt) {
    const p = currentParams();
    syncWorkersToParams();
    simTime += dt * p.speed;

    tBuildAccum += p.buildRate * p.speed * dt;
    const maxBuildPerFrame = 20;
    let builtNow = 0;
    while (tBuildAccum >= 1 && builtNow < maxBuildPerFrame) {
      buildStep(p.storageBias);
      tBuildAccum -= 1;
      builtNow++;
    }

    const { size, ox, oy } = getRenderMetrics();

    for (const w of workers) {
      if (w.t >= 1) {
        const next = pickWorkerNext(w, p.honeyRate);
        if (next) {
          w.t = 0;
          w.tq = next.q;
          w.tr = next.r;

          const from = axialToPixel(w.q, w.r, size, ox, oy);
          const to = axialToPixel(w.tq, w.tr, size, ox, oy);
          trails.push({
            x1: from.x, y1: from.y,
            x2: to.x, y2: to.y,
            life: 1.0,
            phase: rand(TAU, 0),
            width: 1.4 + rand(1.2, 0)
          });

          if (Math.random() < p.sparkRate) {
            const mx = (from.x + to.x) * 0.5;
            const my = (from.y + to.y) * 0.5;
            spawnSparksAt(mx, my, 2 + (Math.random() < 0.25 ? 2 : 0));
          }

          if (trails.length > p.trailKeep) trails.splice(0, trails.length - p.trailKeep);
        } else {
          w.t = 0; w.tq = w.q; w.tr = w.r;
        }
      }

      w.t += dt * p.moveSpeed * p.speed;

      if (w.t >= 1) {
        w.t = 1;
        w.q = w.tq;
        w.r = w.tr;

        const depositProb = 0.012 + 0.034 * p.honeyRate;
        if (Math.random() < depositProb) {
          depositHoney(p.honeyRate, p.storageBias);
          const at = axialToPixel(w.q, w.r, size, ox, oy);
          spawnSparksAt(at.x, at.y, 1 + (Math.random() < 0.20 ? 1 : 0));
        }
      }
    }

    for (const sp of sparks) {
      sp.x += sp.vx * dt;
      sp.y += sp.vy * dt;
      sp.vx *= (1 - 0.9*dt);
      sp.vy *= (1 - 0.9*dt);
    }

    if (honeyKeys.size > 0) {
      const drain = (1 - p.honeyRate) * 0.0012 * p.speed * dt;
      if (drain > 0) {
        for (const k of Array.from(honeyKeys)) {
          const c = cells.get(k);
          c.honey = clamp(c.honey - drain, 0, 1);
          if (c.honey <= 0.001) honeyKeys.delete(k);
        }
      }
    }

    tick++;
  }

  function updateStatsPanel() {
    const p = currentParams();
    const builtCount = builtSet.size;
    const honeyCount = honeyKeys.size;
    const honeyTotal = honeyCount ? Array.from(honeyKeys).reduce((s,k)=>s+cells.get(k).honey,0) : 0;
    const honeyAvg = honeyCount ? honeyTotal / honeyCount : 0;

    statsEl.innerHTML = `
      <div><b>Grid radius:</b> ${p.radius} &nbsp;•&nbsp; <b>Total cells:</b> ${cells.size.toLocaleString()}</div>
      <div><b>Built:</b> ${builtCount.toLocaleString()} &nbsp;•&nbsp; <b>Frontier:</b> ${frontier.size.toLocaleString()}</div>
      <div><b>Workers:</b> ${p.workerCount} &nbsp;•&nbsp; <b>Build rate:</b> ${p.buildRate.toFixed(2)} steps/s</div>
      <div><b>Storage cells:</b> ${honeyCount.toLocaleString()} &nbsp;•&nbsp; <b>Avg fill:</b> ${(honeyAvg*100).toFixed(0)}%</div>
    `;
  }

  // -----------------------------
  // Interaction: pan + pinch zoom (mobile) + wheel zoom (desktop)
  // -----------------------------
  let dragging = false;
  let last = { x:0, y:0 };

  // Multi-touch pinch
  let pinch = { active:false, startDist:0, startZoom:1 };

  function dist(a,b){ const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy); }

  canvas.addEventListener('pointerdown', (e) => {
    canvas.setPointerCapture(e.pointerId);
    // track active pointers for pinch
    activePointers.set(e.pointerId, e);
    if (activePointers.size === 2) {
      const pts = Array.from(activePointers.values());
      pinch.active = true;
      pinch.startDist = dist(pts[0], pts[1]);
      pinch.startZoom = view.zoom;
    } else if (activePointers.size === 1) {
      dragging = true;
      last.x = e.clientX; last.y = e.clientY;
    }
  });

  const activePointers = new Map();

  canvas.addEventListener('pointermove', (e) => {
    if (!activePointers.has(e.pointerId)) return;
    activePointers.set(e.pointerId, e);

    if (pinch.active && activePointers.size === 2) {
      const pts = Array.from(activePointers.values());
      const d = dist(pts[0], pts[1]);
      const ratio = d / (pinch.startDist || d);
      view.zoom = clamp(pinch.startZoom * ratio, 0.55, 1.85);
      return;
    }

    if (!dragging) return;
    const dx = e.clientX - last.x;
    const dy = e.clientY - last.y;
    last.x = e.clientX; last.y = e.clientY;
    view.panX += dx;
    view.panY += dy;
  });

  canvas.addEventListener('pointerup', (e) => {
    activePointers.delete(e.pointerId);
    if (activePointers.size < 2) pinch.active = false;
    if (activePointers.size === 0) dragging = false;
  });
  canvas.addEventListener('pointercancel', (e) => {
    activePointers.delete(e.pointerId);
    pinch.active = false;
    dragging = false;
  });

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    view.zoom = clamp(view.zoom * (delta > 0 ? 0.92 : 1.08), 0.55, 1.85);
  }, { passive:false });

  centerBtn.addEventListener('click', () => { view.panX = 0; view.panY = 0; view.zoom = 1; });

  // -----------------------------
  // Buttons / listeners
  // -----------------------------
  toggleBtn.addEventListener('click', () => {
    running = !running;
    toggleBtn.textContent = running ? 'Pause' : 'Resume';
  });

  resetBtn.addEventListener('click', () => resetSimulation());

  function inferredRadiusFromN(N) { return Math.round((Math.sqrt(12*N - 3) - 3) / 6); }

  function onParamChange() {
    setLabels();
    const p = currentParams();
    const currentR = inferredRadiusFromN(cells.size || 1);
    if (Math.abs(p.radius - currentR) >= 1) resetSimulation();
  }

  colonyEl.addEventListener('input', onParamChange);
  resourcesEl.addEventListener('input', () => setLabels());
  speedEl.addEventListener('input', () => setLabels());

  // -----------------------------
  // Main loop
  // -----------------------------
  let lastT = performance.now();
  function frame(now) {
    const dtMs = now - lastT;
    lastT = now;
    const dt = clamp(dtMs / 1000, 0, 0.05);

    if (running) {
      update(dt);
      if ((tick % 10) === 0) updateStatsPanel();
    }
    draw();
    requestAnimationFrame(frame);
  }

  // Init
  resizeCanvas();
  setLabels();
  initPanelState();
  resetSimulation();
  updateStatsPanel();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
